# functions to work with the coastal datasetimport osimport reimport geopandasfrom ..generic.handler_sentinel2 import \    get_geom_for_tile_code, get_utmzone_from_tile_code, \    get_epsg_from_mgrs_tile, _check_mgrs_codefrom ..generic.handler_landsat import \    get_bbox_from_path_rowdef get_coastal_polygon_of_tile(tile_code, tile_system='MGRS', out_dir=None,                                geom_dir=None, geom_name=None):    tile_code = _check_mgrs_code(tile_code)    if geom_dir is None:        rot_dir = os.sep.join(os.path.realpath(__file__).split(os.sep)[:-3])        geom_dir = os.path.join(rot_dir, 'data')    if geom_name is None: geom_name='GSHHS_f_L1.geojson'    if out_dir is None: out_dir=os.getcwd()    if tile_system=='MGRS':        toi = get_geom_for_tile_code(tile_code) # tile of interest        utm_epsg = get_epsg_from_mgrs_tile(tile_code)    else: # WRS2        #todo        path,row = [],[]        toi = get_bbox_from_path_row(path,row)    # get UTM extent, since not the whole world needs to be included    utm_zone = get_utmzone_from_tile_code(tile_code)    geom_path = os.path.join(geom_dir, geom_name)    assert os.path.exists(geom_path), 'make sure data is present'    gshhs = geopandas.read_file(geom_path)    tile = geopandas.GeoDataFrame(index=[0], crs='epsg:4326',                                  geometry=geopandas.GeoSeries.from_wkt([toi]))    bound = gshhs.clip(tile)    bound = bound.to_crs(epsg=utm_epsg)    # create the output layer    fname_json_utm = geom_name.split('.')[0]+'_utm'+str(utm_zone).zfill(2) + \                    '.geojson'    bound.to_file(os.path.join(out_dir, fname_json_utm), driver='GeoJSON')    print('written ' + fname_json_utm)    return